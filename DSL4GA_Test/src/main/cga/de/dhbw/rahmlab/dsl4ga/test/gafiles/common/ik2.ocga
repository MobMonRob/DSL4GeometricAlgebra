// Inverse Kinematics following A. Marzabal and I. Zaplana: Closed-form inverse kinematics 
// solututions for a class of serial robots without a spherical wrist using conformal geometric algebra.
// Example: UR5e robot placed at the origin of the coordinate system


// up/down projection

// up projection of a vector into a cga multivector, results in a round point
fn up(vec){
	vec + 0.5vec²εᵢ+ε₀
}

// down projection of a multivector into an euclidean vector
// euclidean location of a round point
fn down(vec){
    // normalized sphere in ipns respresentation
	// TODO muss da noch ein weiterer Rechenschritt erfolgen?
	//-vec/(εᵢ⌋vec)

	// extracts the pure euclidean part of the given multivector
    // E0 symbol verwenden
	//TODO test
	E₀⌋(vec∧E₀)
}


// creates spheres

// round point from 3 euclidean coordinates
fn rp(x,y,z){
	//p := xε₁+yε₂+zε₃
    //p + 0.5p²εᵢ+ε₀
	up(xε₁+yε₂+zε₃)
}

// ipns sphere from midpoint and radius
// m round point
fn sp(m,r){
	// up(center)-(0.5*einf*radius**2)
	m - 0.5r²εᵢ
}


// create planes

// ipns plane from euclidean normal vec und dist to the origin
fn pl(vec, d){
	vec + d εᵢ
}

// extract euclidean coordinates

// three euclidean coordinates from a round point
// TODO test identisch zu down?
fn ep(rp){
	(ε₀∧εᵢ)⋅(rp∧(ε₀∧εᵢ))
}
// euclidean points from a point pair
fn epp(pp){
    // def getPointsFromBivector(bivec):
	//        F = bivec/math.sqrt(abs(bivec**2))
	//        P = 0.5*(1+F)
    //        P_inv = 0.5*(1-F)
    //        p1 = down(-P_inv*(bivec | einf)*P)
    //        p2 = down(P*(bivec | einf)*P_inv)
    //        return(p1,p2)
	ppnorm := sqrt(squaredNorm(pp)
    (pp+ppnorm)/(-εᵢ⋅pp), (pp-ppnorm)/(-εᵢ⋅pp)
}

// TODO test
fn sign(scalar){
	scalar/abs(scalar)
}

// get e1 component from the given multivector vec
fn x(vec){
	(down(vec)∧ε₂∧ε₃)E₃
	// TODO test 
	//TODO da muss ich jetzt noch den korrespondierenden e1 vec draus machen 
    // mit E23 multiplizieren oder so ähnlich, vielleicht E123, euclidischer Pseusoscalar
}
fn y(vec){
	(down(vec)∧ε₁∧ε₃)E₃
	// TODO test 
}
fn z(vec){
	(down(vec)∧ε₁∧ε₂)E₃
	// TODO test 
}

// transformations

// round point and rotor as arguments, round point as result values
fn transform(p, rot){
	//TODO test
	rot p rot˜
}

// euclidean vec, cga rotor as arguments
// TODO test
fn transform_vec(vec, rot){
	down(transform(up(vec),rot))
}

fn getTranslationRotor(vec){
	// e**(-0.5*vec*einf)
	//TODO test
	exp(-0.5 vec εᵢ)
}

fn getRotationRotor(theta, axis){
	//e**(-0.5*theta*axis*I_base)
	//TODO test
	exp(-0.5 theta axis I_base)
}

// arguments as cga multivector types, represented as sparse matrices
fn main(pos, rot) {

	// nominal dh parameters UR5e, the d-parameters correspond to the link lengths
    // and fullfill the assumption to apply the approach
	a2 := -0.425
	a3 := -0.3922
	d1 := 0.1625
	d4 := 0.1333
	d5 := 0.0997
	d6 := 0.0996

	// robots end-effector pose
    //p6 := rp(-0.5, 0.0, 0.0)
    p6 := pos
    R6 := rot
    // end_factor_Zaxis
    z6 :=  transform_vec(ε₃, R6)

    // robots origin
    p0 := ε₀ // equivalent to rp(0.0, 0.0, 0.0)

	// p1 lies between links 1 and 2
    // defined by translation of p0 along the z-axis of the reference distance d1
    // which is the first link
	//T10 := 1 + 0.5d1ε₃εᵢ //FIXME e3 und einf tauschen?
    //p1 := T10 p0 T10˜
	T1 := getTranslationRotor(d1 ε₃)
	p1 := transform_vec(p0, T1)

	// p5 is the translation of p6 along the (minus) z-axis
	// about a distance d6, which is the length of the last link
	//T56 := 1 - 0.5d6ε₃εᵢ //FIX e3 und einf tauschen?
	//p5 = T56 p6 T56˜
    T65 := getTranslationRotor(d6 z6)
    p5 := transform(p6, T65)


	// p4 with 4 possible solutions

	// or down(p6)-down(p5)
	v56 := normalize(ep(p6)-ep(p5))
	
    // ipns sphere with center p5 and radius d5
	S5 := sp(p5, d5) // S5 := p5 - 0.5d5²εᵢ

    // plane with normal vector from p5 to p6 through p5

	//Pl5 := v56 + (p5⋅v56)εᵢ
	Pl5 := pl(v56, p5⋅v56)
    //alternative fomulation: plane between p5 and p5 tranlated into p5 (half distance subtraction)
    //Pl5 := p6-p5-0.5.... TODO
	
	// TODO das scheint z(p5)/y(p5) zu sein
    // wie bekomme ich die components aus p5 raus um atan2 verwenden zu können
    // oder kann ich atan(down(p5)) verwenden, dann muss ich aber atan() implementieren
	// psi = atan(p5.value[2]/p5.value[1])
	psi = atan2(z(p5), y(p5))
    theta := asin(d4/sqrt(y(p5)²+z(p5)²))


	// Solution 1 for p4

	// TODO was für ein Winkel ist das?
    alpha_1 := psi - theta

	// TODO cos() implementieren
	pl_vert_45_vec_1a := cos(alpha_1+π/2)ε₁+sin(alpha_1+π/2)ε₂
	pl_vert_45_vec_1 := pl_vert_45_vec_1a sign(pl_vert_45_vec_1a⋅p5)
	// ipns plane
	pl_vert_45_1 := pl(plane_vert_45_vec_1, d4)

	// point pair
    pp4_sol_1 := (s5∧pl5∧pl_vert_45_1)* // TODO oder undual?




    // TODO define dm as norm of the middle point of the projection of the segment Op5 to
    // the xy-plane
    Sm := m-0.5dm²εᵢ
	S0 := sp(ε₀, d4) //S0 :=ε₀-0.5d4²εᵢ
    Plxy := ε₃
	// intersection of the above three geometric objects
    // = outer representation of the pair of points v1, v2 representing the normal vectors
    // of the two possible vertical planes that contains p5 and have 
    // a distance vector d4 to the origin
    Btan := (Sm∧S0∧Plxy)* // outer representation of a point pair, representing normal vectors of
    // two possible planes that contains pt5 and have a distance d4 to the origin
    v1, v2 = epp(Btan) // decompose the euclidean points coordinates from a point pair 
    // inner representation of these two planes:
    Pl41 := v1+d4εᵢ
	Pl42 := v2+d4εᵢ

    B4 := Pl5∧S5∧Pl41 // bivector representing two points
    //TODO extract 4 possibilities of p4 from B4
    





    // p3 as translation of p4 along v4 by an amount d4
    T34 := 1-0.5d4εᵢv4
	p31 := T34 p41 T34˜
	p32 := T34 p42 T34˜
	p33 := T34 p43 T34˜
	p34 := T34 p44 T34˜

    // TODO define all variants based on the 4 variants of p3
    S1 := p1 - 0.5a2²εᵢ
    S3 := p3 - 0.5a3²εᵢ
    Pl := (p0∧p2∧p3∧εᵢ)*
    
    // TODO outer representation of the two possible values for p2 for each of the 4 points p3
    B2 := S1∧S3∧Pl

    // define the geometric objects to determine the joint angles
    PIxy = 
}